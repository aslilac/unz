{"version":3,"file":"unzzz.js","sources":["../lib/unzzz.js"],"sourcesContent":["// MIT License / Copyright Kayla Washburn 2018\n\"use strict\";\n\nimport fs from 'fs'\nimport path from 'path'\nimport zlib from 'zlib'\n\nimport gardens from 'gardens'\nconst garden = gardens.createScope( 'unzzz' )\n\nconst END_OF_CENTRAL_DIRECTORY = Buffer.from([ 0x50, 0x4b, 0x05, 0x06 ])\nconst CENTRAL_DIRECTORY = Buffer.from([ 0x50, 0x4b, 0x01, 0x02 ])\nconst LOCAL_FILE = Buffer.from([ 0x50, 0x4b, 0x03, 0x04 ])\nconst LOCAL_FILE_DESCRIPTOR = Buffer.from([ 0x50, 0x4b, 0x07, 0x08 ])\n\n// Convert a Little Endian buffer to an int\nfunction leToInt( bufferSegment ) {\n  let total = 0\n  bufferSegment.forEach( ( item, significance ) => {\n    total += item * 2**(significance*8)\n  })\n\n  return total\n}\n\nclass Reader {\n  constructor( buffer, position = 0 ) {\n    this.currentBuffer = buffer\n    this.position = position\n  }\n\n  findNext( data ) {\n    let foundAt = this.currentBuffer.slice( this.position ).indexOf( data )\n    this.position += foundAt\n\n    return foundAt > -1\n  }\n\n  moveTo( position ) {\n    this.position = position\n  }\n\n  peek( length ) {\n    return this.currentBuffer.slice( this.position, this.position + length )\n  }\n\n  readLittleEndian( length ) {\n    let value = leToInt( this.currentBuffer.slice( this.position, this.position + length ) )\n    this.position += length\n    return value\n  }\n\n  readRaw( length ) {\n    let value = this.currentBuffer.slice( this.position, this.position + length )\n    this.position += length\n    return value\n  }\n\n  readString( length, encoding = 'utf-8' ) {\n    let value = this.currentBuffer.slice( this.position, this.position + length ).toString( encoding )\n    this.position += length\n    return value\n  }\n}\n\nclass Unzzz {\n  constructor() {\n    this.files = {}\n    this.map = {}\n  }\n\n  read( archive ) {\n    return new Promise( ( fulfill, reject ) => {\n      fs.readFile( archive, ( error, archiveBuffer ) => {\n        if ( error ) {\n          reject( error )\n          throw garden.error( 'Unable to read file' )\n        }\n\n        this.readBuffer( archiveBuffer ).then( fulfill, reject )\n      })\n    })\n  }\n\n  readBuffer( archiveBuffer ) {\n    return new Promise( ( fulfill, reject ) => {\n      this.archiveBuffer = archiveBuffer\n\n      this._begin()\n      this._validateMap()\n\n      fulfill( this )\n    })\n  }\n\n  _validateMap() {\n    // This checks to make sure that all the data in the file is accounted for.\n    // If there is unnecessary data in the file, that raises a red flag in my eyes.\n    // Every block should end at either the beginning of the next block or the end\n    // of the file.\n    let position = 0\n    while ( this.map[ position ] ) position = this.map[ position ]\n    garden.assert_eq( position, this.archiveBuffer.length )\n  }\n\n  _begin() {\n    let reader = new Reader( this.archiveBuffer )\n    reader.findNext( END_OF_CENTRAL_DIRECTORY )\n\n    let eocd = {\n      _begin: reader.position,\n      signature: reader.readLittleEndian( 4 ),\n      diskNumber: reader.readLittleEndian( 2 ),\n      centralDirectoryStartDisk: reader.readLittleEndian( 2 ),\n      localListingCount: reader.readLittleEndian( 2 ),\n      globalListingCount: reader.readLittleEndian( 2 ),\n      sizeOfCentralDirectory: reader.readLittleEndian( 4 ),\n      startOfCentralDirectory: reader.readLittleEndian( 4 ),\n      commentLength: reader.readLittleEndian( 2 )\n    }\n\n    // This is separate so that we can know the commentLength\n    Object.assign( eocd, {\n      comment: reader.readRaw( eocd.commentLength ),\n      _end: reader.position\n    })\n\n    // Assert that the signature is correct\n    garden.assert_eq( eocd.signature, leToInt( END_OF_CENTRAL_DIRECTORY ) )\n    // Assert that there is only one disk\n    garden.assert_eq( eocd.diskNumber, 0 )\n    garden.assert_eq( eocd.centralDirectoryStartDisk, 0 )\n    garden.assert_eq( eocd.localListingCount, eocd.globalListingCount )\n\n    // Store mapping data\n    this.map[ eocd._begin ] = eocd._end\n    this.endOfCentralDirectory = eocd\n\n    this._parseCentralDirectoryHeaders()\n  }\n\n  _parseCentralDirectoryHeaders() {\n    let eocd = this.endOfCentralDirectory\n    let reader = new Reader( this.archiveBuffer, eocd.startOfCentralDirectory )\n\n    // Read all of our listings\n    for ( let i = 0; i < eocd.globalListingCount; i++ ) {\n      let listing = {\n        _begin: reader.position,\n        // TODO validate signatures and remove .toString()\n        signature: reader.readLittleEndian( 4 ),\n        versionMadeBy: reader.readLittleEndian( 2 ),\n        versionNeeded: reader.readLittleEndian( 2 ),\n        bitFlag: reader.readLittleEndian( 2 ),\n        compressionMethod: reader.readLittleEndian( 2 ),\n        modifiedTime: reader.readLittleEndian( 2 ),\n        modifiedDate: reader.readLittleEndian( 2 ),\n        crc32: reader.readLittleEndian( 4 ),\n        compressedSize: reader.readLittleEndian( 4 ),\n        uncompressedSize: reader.readLittleEndian( 4 ),\n        fileNameLength: reader.readLittleEndian( 2 ),\n        extraLength: reader.readLittleEndian( 2 ),\n        commentLength: reader.readLittleEndian( 2 ),\n        fileDisk: reader.readLittleEndian( 2 ),\n        internalAttributes: reader.readLittleEndian( 2 ),\n        externalAttributes: reader.readLittleEndian( 4 ),\n        fileHeaderOffset: reader.readLittleEndian( 4 )\n      }\n\n      // This is separate so that we can know fileNameLength, extraLength, commentLength\n      Object.assign( listing, {\n        fileName: reader.readString( listing.fileNameLength ),\n        extra: reader.readRaw( listing.extraLength ),\n        comment: reader.readRaw( listing.commentLength ),\n        _end: reader.position\n      })\n\n      // Parse the local header once we've located it\n      listing.localHeader = this._parseLocalFileHeader( listing )\n\n      // Assert that the signature is correct\n      garden.assert_eq( listing.signature, leToInt( CENTRAL_DIRECTORY ) )\n      // Assert that information matches in both listings\n      garden.assert_eq( listing.compressionMethod, 8 )\n      garden.assert_eq( listing.localHeader.compressionMethod, 8 )\n      garden.assert_eq( listing.modifiedTime, listing.localHeader.modifiedTime )\n      garden.assert_eq( listing.modifiedDate, listing.localHeader.modifiedDate )\n      garden.assert_eq( listing.crc32, listing.localHeader.crc32 )\n      garden.assert_eq( listing.compressedSize, listing.localHeader.compressedSize )\n      garden.assert_eq( listing.uncompressedSize, listing.localHeader.uncompressedSize )\n      garden.assert_eq( listing.fileName, listing.localHeader.fileName )\n      garden.assert_eq( listing.fileDisk, 0 )\n\n      // Store mapping data\n      this.map[ listing._begin ] = listing._end\n      this.files[ listing.fileName ] = listing\n    }\n\n    // Assert that the central directory is the correct size\n    garden.assert_eq( eocd.sizeOfCentralDirectory, reader.position - eocd.startOfCentralDirectory )\n  }\n\n  _parseLocalFileHeader( directoryListing ) {\n    let reader = new Reader( this.archiveBuffer, directoryListing.fileHeaderOffset )\n\n    let localHeader = {\n      _begin: reader.position,\n      signature: reader.readLittleEndian( 4 ),\n      versionNeeded: reader.readLittleEndian( 2 ),\n      bitFlag: reader.readLittleEndian( 2 ),\n      compressionMethod: reader.readLittleEndian( 2 ),\n      modifiedTime: reader.readLittleEndian( 2 ),\n      modifiedDate: reader.readLittleEndian( 2 ),\n      crc32: reader.readLittleEndian( 4 ),\n      compressedSize: reader.readLittleEndian( 4 ),\n      uncompressedSize: reader.readLittleEndian( 4 ),\n      fileNameLength: reader.readLittleEndian( 2 ),\n      extraLength: reader.readLittleEndian( 2 )\n    }\n\n    localHeader.fileName = reader.readString( localHeader.fileNameLength )\n    localHeader.extra = reader.readRaw( localHeader.extraLength )\n\n    // This must be set before the descriptor nonsense because that puts us in\n    // COMPLETELY the wrong spot.\n    directoryListing.startOfData = reader.position\n    directoryListing.endOfData = directoryListing.startOfData + directoryListing.compressedSize\n    localHeader._end = directoryListing.endOfData\n\n    if ( localHeader.bitFlag & 8 ) {\n      reader.position += directoryListing.compressedSize\n      localHeader._descriptorBegin = reader.position\n\n      // This signature is optional, so check if we need to eat it\n      reader.peek( 4 ).equals( LOCAL_FILE_DESCRIPTOR ) && reader.readRaw( 4 )\n\n      Object.assign( localHeader, {\n        crc32: reader.readLittleEndian( 4 ),\n        compressedSize: reader.readLittleEndian( 4 ),\n        uncompressedSize: reader.readLittleEndian( 4 )\n      })\n\n      localHeader._end = reader.position\n    }\n\n    // Assert that the signature is correct\n    garden.assert_eq( localHeader.signature, leToInt( LOCAL_FILE ) )\n\n    // Store mapping data\n    this.map[ localHeader._begin ] = localHeader._end\n    return localHeader\n  }\n\n  unzipBuffer( from ) {\n    return new Promise( ( fulfill, reject ) => {\n      let listing = this.files[ from ]\n\n      zlib.inflateRaw( this.archiveBuffer.slice( listing.startOfData, listing.endOfData ), ( error, buffer ) => {\n        if ( error ) {\n          reject( error )\n          return garden.error( 'Failed to unzip file', error )\n        }\n        garden.assert_eq( listing.uncompressedSize, buffer.length )\n\n        fulfill( buffer )\n      })\n    })\n  }\n\n  unzipFile( from, to = path.basename( from ) ) {\n    return new Promise( ( fulfill, reject ) => {\n      this.unzipBuffer( from ).then( buffer => {\n        fs.writeFile( to, buffer, error => {\n          if ( error ) {\n            reject( error )\n            return garden.error( `Failed to write file ${ to }`, error )\n          }\n\n          fulfill()\n        })\n      })\n    })\n  }\n\n  safeUnzipFile( from, to = from ) {\n    return new Promise( ( fulfill, reject ) => {\n      this.unzipBuffer( from ).then( buffer => {\n        fs.stat( to, ( error, stat ) => {\n          // Ignore errors because it probably just doesn't exist.\n          // We actually care about stat, because we don't want it to exist.\n          if ( stat ) throw garden.error( `Attempting to unzip file to ${ to } but it already exists!` )\n\n          fs.writeFile( to, buffer, error => {\n            if ( error ) {\n              reject( error )\n              return garden.error( 'Failed to write file', error )\n            }\n\n            fulfill()\n          })\n        })\n      })\n    })\n  }\n}\n\nexport default function ( source ) {\n  let archive = new Unzzz()\n  if ( Buffer.isBuffer( source ) ) return archive.readBuffer( source )\n  else if ( typeof source === 'string' ) return archive.read( source )\n  else throw garden.typeerror( 'Unzzz: Argument `source` must be a file path (string) or a buffer.' )\n}\n"],"names":[],"mappings":"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"}